using System;
using System.Collections.Generic;
using System.Linq;
using System.Text.Json;
using System.Threading.Tasks;
using Microsoft.EntityFrameworkCore;
using teamseven.EzExam.Repository;
using teamseven.EzExam.Repository.Models;
using teamseven.EzExam.Services.Object.Requests;
using teamseven.EzExam.Services.Object.Responses;
using teamseven.EzExam.Repository.Dtos;

namespace teamseven.EzExam.Services.Services.ExamService
{
    public class ExamService : IExamService
    {
        private readonly IUnitOfWork _unitOfWork;

        public ExamService(IUnitOfWork unitOfWork)
        {
            _unitOfWork = unitOfWork ?? throw new ArgumentNullException(nameof(unitOfWork));
        }

        public async Task<int> CreateExamAsync(ExamRequest examRequest)
        {
            if (examRequest == null)
                throw new ArgumentNullException(nameof(examRequest));

            var exam = new Exam
            {
                Name = examRequest.Name,
                Description = examRequest.Description,
                SubjectId = examRequest.SubjectId,
                LessonId = examRequest.LessonId,
                ExamTypeId = examRequest.ExamTypeId,
                Duration = examRequest.Duration,
                CreatedByUserId = examRequest.CreatedByUserId,
                CreatedAt = DateTime.UtcNow,
                IsDeleted = false
            };

            await _unitOfWork.ExamRepository.AddAsync(exam);
            await _unitOfWork.SaveChangesWithTransactionAsync();
            return exam.Id;
        }

        public async Task<ExamResponse> UpdateExamAsync(UpdateExamRequest updateExamRequest)
        {
            if (updateExamRequest == null)
                throw new ArgumentNullException(nameof(updateExamRequest));

            var existingExam = await _unitOfWork.ExamRepository.GetByIdAsync(updateExamRequest.Id);
            if (existingExam == null)
                throw new ArgumentException($"Exam with ID {updateExamRequest.Id} not found");

            // Update fields
            existingExam.Name = updateExamRequest.Name;
            existingExam.Description = updateExamRequest.Description;
            existingExam.SubjectId = updateExamRequest.SubjectId;
            existingExam.LessonId = updateExamRequest.LessonId;
            existingExam.ExamTypeId = updateExamRequest.ExamTypeId;
            existingExam.TimeLimit = updateExamRequest.TimeLimit;
            existingExam.TotalQuestions = updateExamRequest.TotalQuestions ?? existingExam.TotalQuestions;
            existingExam.TotalMarks = updateExamRequest.TotalMarks;
            existingExam.Duration = updateExamRequest.Duration ?? existingExam.Duration;
            existingExam.TestConfiguration = updateExamRequest.TestConfiguration;
            existingExam.DifficultyDistribution = updateExamRequest.DifficultyDistribution;
            existingExam.TopicDistribution = updateExamRequest.TopicDistribution;
            existingExam.IsAutoGenerated = updateExamRequest.IsAutoGenerated ?? existingExam.IsAutoGenerated;
            existingExam.GenerationSource = updateExamRequest.GenerationSource;
            existingExam.AITestRecommendationId = updateExamRequest.AITestRecommendationId;
            existingExam.IsActive = updateExamRequest.IsActive ?? existingExam.IsActive;
            existingExam.IsPublic = updateExamRequest.IsPublic ?? existingExam.IsPublic;
            existingExam.UpdatedAt = DateTime.UtcNow;

            await _unitOfWork.ExamRepository.UpdateAsync(existingExam);
            await _unitOfWork.SaveChangesWithTransactionAsync();

            return new ExamResponse
            {
                Id = existingExam.Id,
                Name = existingExam.Name,
                Description = existingExam.Description,
                SubjectId = existingExam.SubjectId,
                LessonId = existingExam.LessonId,
                ExamTypeId = existingExam.ExamTypeId,
                CreatedByUserId = existingExam.CreatedByUserId,
                TimeLimit = existingExam.TimeLimit,
                TotalQuestions = existingExam.TotalQuestions,
                TotalMarks = existingExam.TotalMarks,
                Duration = existingExam.Duration,
                TestConfiguration = existingExam.TestConfiguration,
                DifficultyDistribution = existingExam.DifficultyDistribution,
                TopicDistribution = existingExam.TopicDistribution,
                IsAutoGenerated = existingExam.IsAutoGenerated,
                GenerationSource = existingExam.GenerationSource,
                AITestRecommendationId = existingExam.AITestRecommendationId,
                IsDeleted = existingExam.IsDeleted,
                IsActive = existingExam.IsActive,
                IsPublic = existingExam.IsPublic,
                CreatedAt = existingExam.CreatedAt,
                UpdatedAt = existingExam.UpdatedAt
            };
        }

        public Task CreateExamHistoryAsync(ExamHistoryRequest examHistoryRequest)
        {
            throw new NotImplementedException();
        }
        public async Task SoftDeleteExamAsync(int examId)
        {
            var exam = await _unitOfWork.ExamRepository.GetByIdAsync(examId);
            if (exam == null)
                throw new ArgumentException("Exam not found");

            if (exam.IsDeleted == true)
                return; // xoa roi thi next

            exam.IsDeleted = true;
            exam.UpdatedAt = DateTime.UtcNow;

            _unitOfWork.ExamRepository.Update(exam);
            await _unitOfWork.SaveChangesWithTransactionAsync();
        }
        public async Task RecoverExamAsync(int examId)
        {
            var exam = await _unitOfWork.ExamRepository.GetByIdAsync(examId);
            if (exam == null)
                throw new ArgumentException("Exam not found");

            if (exam.IsDeleted == false)
                return;

            exam.IsDeleted = false;
            exam.UpdatedAt = DateTime.UtcNow;

            _unitOfWork.ExamRepository.Update(exam);
            await _unitOfWork.SaveChangesWithTransactionAsync();
        }



        public async Task CreateExamQuestionAsync(ExamQuestionRequest examQuestionRequest)
        {
            if (examQuestionRequest == null)
                throw new ArgumentNullException(nameof(examQuestionRequest));

            var examExists = await _unitOfWork.ExamRepository.GetByIdAsync(examQuestionRequest.ExamId);
            if (examExists == null)
                throw new ArgumentException("Exam not found");

            var questionExists = await _unitOfWork.QuestionRepository.GetByIdAsync(examQuestionRequest.QuestionId);
            if (questionExists == null)
                throw new ArgumentException("Question not found");

            // Check if the question is already assigned to the exam
            if (await _unitOfWork.ExamQuestionRepository.GetByExamAndQuestionIdAsync(examQuestionRequest.ExamId, examQuestionRequest.QuestionId) != null)
                throw new InvalidOperationException("Question is already assigned to this exam");


            var examQuestion = new ExamQuestion
            {
                ExamId = examQuestionRequest.ExamId,
                QuestionId = examQuestionRequest.QuestionId,
                Order = examQuestionRequest.Order,
                CreatedAt = DateTime.UtcNow
            };

            await _unitOfWork.ExamQuestionRepository.AddAsync(examQuestion);
            await _unitOfWork.SaveChangesWithTransactionAsync();
        }


        public Task DeleteExamHistoryAsync(ExamHistoryRequest historyRequest)
        {
            throw new NotImplementedException();
        }

        public async Task<IEnumerable<ExamResponse>> GetAllExamAsync()
        {
            var exams = await _unitOfWork.ExamRepository.GetAllAsync();
            return exams.Select(e => new ExamResponse
            {
                Id = e.Id,
                Name = e.Name,
                LessonId = e.LessonId,
                SubjectId = e.SubjectId,
                ExamTypeId = e.ExamTypeId,
                CreatedByUserId = e.CreatedByUserId,
                IsDeleted = e.IsDeleted,
                CreatedAt = e.CreatedAt,
                UpdatedAt = e.UpdatedAt,
                CreatedByUserName = e.CreatedByUser?.Email,
                ExamTypeName = e.ExamType?.Name,
                LessonName = e.Lesson?.Name,
                Duration = e.Duration,
                QuestionCount = e.ExamQuestions?.Count ?? 0,
                HistoryCount = 0 
            }).ToList();
        }

        public async Task<ExamResponse> GetExamAsync(int id)
        {
            var exam = await _unitOfWork.ExamRepository.GetByIdAsync(id);
            if (exam == null)
                throw new ArgumentException("Exam not found");

            return new ExamResponse
            {
                Id = exam.Id,
                Name = exam.Name,
                LessonId = exam.LessonId,
                ExamTypeId = exam.ExamTypeId,
                CreatedByUserId = exam.CreatedByUserId,
                IsDeleted = exam.IsDeleted,
                CreatedAt = exam.CreatedAt,
                UpdatedAt = exam.UpdatedAt,
                CreatedByUserName = exam.CreatedByUser?.Email,
                ExamTypeName = exam.ExamType?.Name,
                LessonName = exam.Lesson?.Name,
                Duration = exam.Duration,
                QuestionCount = exam.ExamQuestions?.Count ?? 0,
                HistoryCount = 0 
            };
        }

        public Task<ExamHistoryResponseDto> GetExamHistoryResponseAsync(int id)
        {
            throw new NotImplementedException();
        }
        public async Task RenameExamAsync(int examId, string newName)
        {
            if (string.IsNullOrWhiteSpace(newName))
                throw new ArgumentException("New exam name cannot be empty");

            var exam = await _unitOfWork.ExamRepository.GetByIdAsync(examId);
            if (exam == null)
                throw new ArgumentException("Exam not found");

            exam.Name = newName;
            exam.UpdatedAt = DateTime.UtcNow;

            _unitOfWork.ExamRepository.Update(exam);
            await _unitOfWork.SaveChangesWithTransactionAsync();
        }

        public async Task<IEnumerable<ExamQuestionResponse>> GetExamQuestionByIdAsync(int id)
        {
            var examQuestions = await _unitOfWork.ExamQuestionRepository.GetByExamIdAsync(id);
            if (!examQuestions.Any())
                return new List<ExamQuestionResponse>();

            return examQuestions.Select(eq => new ExamQuestionResponse
            {
                Id = eq.Id,
                ExamId = eq.ExamId,
                QuestionId = eq.QuestionId,
                Order = eq.Order,
                CreatedAt = eq.CreatedAt,
                ExamName = eq.Exam?.Name,
                QuestionContent = eq.Question?.Content
            }).ToList();
        }

        public async Task<IEnumerable<ExamQuestionDetailResponse>> GetExamQuestionsDetailAsync(int examId)
        {
            var examQuestions = await _unitOfWork.ExamQuestionRepository.GetByExamIdAsync(examId);
            if (!examQuestions.Any())
                return new List<ExamQuestionDetailResponse>();

            var questionResponses = new List<ExamQuestionDetailResponse>();

            foreach (var examQuestion in examQuestions.OrderBy(eq => eq.Order))
            {
                var question = examQuestion.Question;
                if (question == null) continue;

                // Get answers for options fallback if Options field is empty
                var options = new List<string>();
                if (!string.IsNullOrEmpty(question.Options))
                {
                    try
                    {
                        options = JsonSerializer.Deserialize<List<string>>(question.Options) ?? new List<string>();
                    }
                    catch
                    {
                        // Fallback to answers if JSON parsing fails
                        var answers = await _unitOfWork.AnswerRepository.GetByQuestionIdAsync(question.Id);
                        options = answers?.Select(a => a.Content).ToList() ?? new List<string>();
                    }
                }
                else
                {
                    // Fallback to answers if Options is empty
                    var answers = await _unitOfWork.AnswerRepository.GetByQuestionIdAsync(question.Id);
                    options = answers?.Select(a => a.Content).ToList() ?? new List<string>();
                }

                var questionResponse = new ExamQuestionDetailResponse
                {
                    Id = question.Id,
                    ContentQuestion = question.Content ?? string.Empty,
                    CorrectAnswer = question.CorrectAnswer,
                    Options = options,
                    Explanation = question.Explanation,
                    ImageUrl = question.Image,
                    Formula = question.Formula
                };

                questionResponses.Add(questionResponse);
            }

            return questionResponses;
        }
        public async Task<IEnumerable<ExamResponse>> GetExamsByUserIdAsync(int userId)
        {
            var exams = await _unitOfWork.ExamRepository.GetByCreatorAsync(userId);
            return exams.Select(e => new ExamResponse
            {
                Id = e.Id,
                Name = e.Name,
                LessonId = e.LessonId,
                ExamTypeId = e.ExamTypeId,
                CreatedByUserId = e.CreatedByUserId,
                IsDeleted = e.IsDeleted,
                CreatedAt = e.CreatedAt,
                UpdatedAt = e.UpdatedAt,
                CreatedByUserName = e.CreatedByUser?.Email,
                ExamTypeName = e.ExamType?.Name,
                LessonName = e.Lesson?.Name,
                QuestionCount = e.ExamQuestions?.Count ?? 0,
                HistoryCount = 0 
            }).ToList();
        }

        //

        public async Task RemoveExamQuestion(ExamQuestionRequest examQuestionRequest)
        {
            if (examQuestionRequest == null)
                throw new ArgumentNullException(nameof(examQuestionRequest));

            var examQuestion = await _unitOfWork.ExamQuestionRepository.GetByExamAndQuestionIdAsync(
                examQuestionRequest.ExamId,
                examQuestionRequest.QuestionId);

            if (examQuestion == null)
                throw new ArgumentException("Exam question not found");

            await _unitOfWork.ExamQuestionRepository.DeleteAsync(examQuestion);
            await _unitOfWork.SaveChangesWithTransactionAsync();
        }

        // Services/Services/ExamService/ExamQueryService.cs
        public async Task<PagedResponse<ExamResponse>> GetExamsAsync(
            int? pageNumber = null,
            int? pageSize = null,
            string? search = null,
            string? sort = null,
            int? subjectId = null,
            int? lessonId = null,
            int? examTypeId = null,
            int? createdByUserId = null,
            int isSort = 0)
        {
            var pn = pageNumber.GetValueOrDefault(1);
            var ps = pageSize.GetValueOrDefault(20);

            var (items, total) = await _unitOfWork.ExamRepository.GetPagedAsync(
                pn, ps, search, sort,
                subjectId, lessonId, examTypeId, createdByUserId, isSort);

            var list = items.Select(x => new ExamResponse
            {
                Id = x.Id,
                Name = x.Name,
                Description = x.Description,
                SubjectId = x.SubjectId,
                LessonId = x.LessonId,
                ExamTypeId = x.ExamTypeId,
                CreatedByUserId = x.CreatedByUserId,
                TimeLimit = x.TimeLimit,
                Duration = x.Duration,
				TotalQuestions = x.TotalQuestions,
                IsActive = x.IsActive,
                IsPublic = x.IsPublic,
                CreatedAt = x.CreatedAt,
                UpdatedAt = x.UpdatedAt
            }).ToList();

            return new PagedResponse<ExamResponse>(list, pn, ps, total);
        }

        // =================== OPTIMIZED: Exams Feed ===================
        // Lightweight projection using single query to avoid N+1. Suitable for catalog listing.
        public async Task<PagedResponse<ExamFeedResponse>> GetOptimizedExamsFeedAsync(
            int page = 1,
            int pageSize = 20,
            string? search = null,
            int? subjectId = null,
            int? lessonId = null,
            int? examTypeId = null,
            int? createdByUserId = null,
            int isSort = 0)
        {
            if (page <= 0) page = 1;
            if (pageSize <= 0) pageSize = 20;
            var skip = (page - 1) * pageSize;

            var ctx = _unitOfWork.Context;

            // Do not restrict to public exams only in the optimized feed â€” return all non-deleted exams
            // (the caller can still filter by createdByUserId or other criteria). This ensures the
            // optimized feed returns results consistent with GetAll/GetExams when appropriate.
            var baseQuery = ctx.Exams.AsQueryable().Where(e => e.IsDeleted == false);

            if (!string.IsNullOrWhiteSpace(search))
            {
                var s = search.Trim().ToLower();
                baseQuery = baseQuery.Where(e => e.Name.ToLower().Contains(s) || (e.Description != null && e.Description.ToLower().Contains(s)));
            }

            if (subjectId.HasValue) baseQuery = baseQuery.Where(e => e.SubjectId == subjectId.Value);
            if (lessonId.HasValue) baseQuery = baseQuery.Where(e => e.LessonId == lessonId.Value);
            if (examTypeId.HasValue) baseQuery = baseQuery.Where(e => e.ExamTypeId == examTypeId.Value);
            if (createdByUserId.HasValue) baseQuery = baseQuery.Where(e => e.CreatedByUserId == createdByUserId.Value);

            var totalItems = await baseQuery.CountAsync();

            var query = baseQuery.OrderByDescending(e => e.CreatedAt)
                .Skip(skip)
                .Take(pageSize)
                .Select(e => new ExamFeedResponse
                {
                    Id = e.Id,
                    Name = e.Name,
                    Description = e.Description,
                    SubjectId = e.SubjectId,
                    SubjectName = e.Subject != null ? e.Subject.Name : null,
                    LessonId = e.LessonId,
                    LessonName = e.Lesson != null ? e.Lesson.Name : null,
                    ExamTypeName = e.ExamType != null ? e.ExamType.Name : null,
                    CreatedByUserId = e.CreatedByUserId,
                    CreatedByUserName = e.CreatedByUser != null ? e.CreatedByUser.Email : null,
                    CreatedAt = e.CreatedAt,
                    UpdatedAt = e.UpdatedAt,
                    TimeLimit = e.TimeLimit,
                    Duration = e.Duration,

                    TotalQuestions = e.TotalQuestions != 0 ? e.TotalQuestions : ctx.ExamQuestions.Count(eq => eq.ExamId == e.Id),
                    AttemptCount = ctx.ExamHistories.Count(h => h.ExamId == e.Id),
                    AverageScore = ctx.ExamHistories.Where(h => h.ExamId == e.Id).Select(h => (decimal?)h.Score).Average() ?? 0m,
                    // Optimized feed is intentionally anonymous / user-agnostic. Per request, do not compute per-user flags here.
                    IsAttemptedByCurrentUser = false
                })
                .AsNoTracking();

            var items = await query.ToListAsync();
            return new PagedResponse<ExamFeedResponse>(items, page, pageSize, totalItems);
        }

        // =================== OPTIMIZED: Exam Details ===================
        // Returns lightweight details for a single exam including question ids and metadata (no full question payloads).
        public async Task<ExamDetailOptimizedResponse> GetOptimizedExamDetailsAsync(int examId, int currentUserId = 0)
        {
            var ctx = _unitOfWork.Context;

            var exam = await ctx.Exams.AsNoTracking()
                .Where(e => e.Id == examId && e.IsDeleted == false)
                .Select(e => new
                {
                    e.Id,
                    e.Name,
                    e.Description,
                    e.SubjectId,
                    e.LessonId,
                    ExamTypeName = e.ExamType != null ? e.ExamType.Name : null,
                    e.CreatedByUserId,
                    CreatedByUserName = e.CreatedByUser != null ? e.CreatedByUser.Email : null,
                    e.CreatedAt,
                    e.UpdatedAt,
                    e.TimeLimit,
                    e.Duration
                }).FirstOrDefaultAsync();

            if (exam == null) throw new ArgumentException("Exam not found");

            var questionIds = await ctx.ExamQuestions.AsNoTracking()
                .Where(eq => eq.ExamId == examId)
                .OrderBy(eq => eq.Order)
                .Select(eq => eq.QuestionId)
                .ToListAsync();

            var attemptCount = await ctx.ExamHistories.CountAsync(h => h.ExamId == examId);
            var averageScore = await ctx.ExamHistories.Where(h => h.ExamId == examId).Select(h => (decimal?)h.Score).AverageAsync() ?? 0m;
            var isAttempted = currentUserId > 0 && await ctx.ExamHistories.AnyAsync(h => h.ExamId == examId && h.UserId == currentUserId);

            return new ExamDetailOptimizedResponse
            {
                Id = exam.Id,
                Name = exam.Name,
                Description = exam.Description,
                SubjectId = exam.SubjectId,
                LessonId = exam.LessonId,
                ExamTypeName = exam.ExamTypeName,
                CreatedByUserId = exam.CreatedByUserId,
                CreatedByUserName = exam.CreatedByUserName,
                CreatedAt = exam.CreatedAt,
                UpdatedAt = exam.UpdatedAt,
                TimeLimit = exam.TimeLimit,
                Duration = exam.Duration,
                TotalQuestions = questionIds.Count,
                QuestionIds = questionIds,
                AttemptCount = attemptCount,
                AverageScore = averageScore,
                IsAttemptedByCurrentUser = isAttempted
            };
        }

    }
}
